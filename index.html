<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>아스트라 워즈 v2.0 — 확장판</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--size:52px}
  body{font-family:system-ui,Segoe UI,Roboto;display:flex;flex-direction:column;align-items:center;background:#f3f6f8;margin:0;padding:18px;color:#111}
  h1{margin:6px 0 4px;font-size:20px}
  #game{display:flex;gap:18px;align-items:flex-start}
  #board{display:grid;grid-template-columns:repeat(10,var(--size));grid-auto-rows:var(--size);gap:4px;background:#222;padding:8px;border-radius:8px}
  .cell{width:var(--size);height:var(--size);background:#fff;border-radius:6px;display:flex;align-items:center;justify-content:center;position:relative;cursor:pointer;box-shadow:0 1px 0 rgba(0,0,0,.06)}
  .cell.coord{background:linear-gradient(180deg,#f7fbff,#fff)}
  .label{position:absolute;left:4px;top:4px;font-size:9px;color:#666}
  .token{width:38px;height:38px;border-radius:50%;box-shadow:inset 0 -4px 0 rgba(0,0,0,.12);}
  .token.black{background:#0b0b0b}
  .token.white{background:#fff;border:1px solid #ddd}
  .core-border{box-shadow:0 0 0 3px rgba(0,123,255,.14) inset}
  .highlight-move{outline:3px solid rgba(34,197,94,.85);outline-offset:-3px}
  .highlight-attack{outline:3px solid rgba(220,38,38,.85);outline-offset:-3px}
  #sidebar{width:320px}
  #info{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 24px rgba(17,24,39,.06)}
  #hand{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap}
  .badge{padding:6px 8px;background:#eef2ff;border-radius:6px;font-weight:600}
  #log{margin-top:12px;height:260px;overflow:auto;background:#fff;padding:10px;border-radius:8px;border:1px solid #eef2ff}
  button{margin-top:8px;padding:8px 12px;border-radius:8px;border:none;background:#0b5cff;color:#fff;font-weight:700;cursor:pointer}
  button[disabled]{opacity:.45;cursor:default}
  small{color:#666}
</style>
</head>
<body>
  <h1>아스트라 워즈 v2.0 — 확장판</h1>
  <div id="game">
    <div id="board" aria-label="board"></div>
    <div id="sidebar">
      <div id="info">
        <div><span class="badge" id="turnBadge">턴: 플레이어 1</span></div>
        <div style="margin-top:8px"><strong>선택:</strong> <span id="selInfo">없음</span></div>
        <div id="pieceInfo" style="margin-top:8px"></div>
        <div id="controls" style="margin-top:8px"></div>
        <div id="hand"></div>
        <div style="margin-top:8px"><small>목표: 상대 코어(2×2) 점령</small></div>
      </div>
      <div id="log"></div>
    </div>
  </div>

<script>
/* ========= 게임 규격 & 초기화 ========= */
const ROWS = 10, COLS = 10;
const PLAYER = {A:0, B:1};
const CELL = (r,c)=>({r,c});
const boardEl = document.getElementById('board');
const selInfo = document.getElementById('selInfo');
const pieceInfo = document.getElementById('pieceInfo');
const controls = document.getElementById('controls');
const turnBadge = document.getElementById('turnBadge');
const logEl = document.getElementById('log');

function log(s){ logEl.innerHTML += `${s}<br>`; logEl.scrollTop = logEl.scrollHeight; }

/* 셀 구조: {r,c, occupant: null | {player,type}} */
let grid = [];
let currentPlayer = PLAYER.A;
let selected = null; // {r,c}
let highlights = [];

/* 기물 타입과 규칙 정의 */
const TYPES = {
  core: {name:'Core', immobile:true},
  foreguard: {name:'Foreguard', moveDirs:[[1,0],[-1,0],[0,1],[0,-1]], attack:'push'},
  shield: {name:'Shield', moveDirs:[[1,0],[-1,0],[0,1],[0,-1]], attack:'melee', resistPush:true},
  scout: {name:'Scout', moveDirs:[[1,1],[1,-1],[-1,1],[-1,-1]], attack:'jump'},
  bombardier: {name:'Bombardier', moveDirs:[[1,0],[-1,0],[0,1],[0,-1]], range:2, attack:'bomb'}
};

/* 초기 보드 생성 및 초기 배치 */
function initGrid(){
  grid = [];
  boardEl.innerHTML = '';
  for(let r=1;r<=ROWS;r++){
    for(let c=1;c<=COLS;c++){
      const cell = {r,c,occupant:null,el:null};
      const div = document.createElement('div');
      div.className='cell';
      div.dataset.r=r; div.dataset.c=c;
      const lbl = document.createElement('div'); lbl.className='label'; lbl.textContent = `${String.fromCharCode(96 + c)}${r}`;
      div.appendChild(lbl);
      div.addEventListener('click', ()=>onCellClick(r,c));
      cell.el = div;
      grid.push(cell);
      boardEl.appendChild(div);
    }
  }
  placeInitialPieces();
  renderAll();
}

/* helpers */
function idx(r,c){ return grid.find(g => g.r===r && g.c===c); }
function inBoard(r,c){ return r>=1 && r<=ROWS && c>=1 && c<=COLS; }
function setOcc(r,c,occ){ const cell = idx(r,c); if(cell) cell.occupant = occ; }

/* 코어 위치 (요청대로) 
   플레이어 A(0) core: (2,e),(2,f),(3,e),(3,f) => rows 2-3, cols 5-6
   플레이어 B(1) core: (8,h),(8,i),(9,h),(9,i) => rows 8-9, cols 8-9
*/
function placeInitialPieces(){
  // clear
  grid.forEach(g=> g.occupant = null);
  // Place A core (player 0)
  for (const [r,c] of [[2,5],[2,6],[3,5],[3,6]]) setOcc(r,c,{player:PLAYER.A,type:'core'});
  // Place B core (player 1)
  for (const [r,c] of [[8,8],[8,9],[9,8],[9,9]]) setOcc(r,c,{player:PLAYER.B,type:'core'});

  // Fill first two rows (1-2) for A with pieces (excluding core locations)
  // We'll distribute: foreguard x6, shield x2, scout x2, bombardier x2 on available slots in rows1-2
  const aPieces = ['foreguard','foreguard','foreguard','foreguard','foreguard','foreguard','shield','shield','scout','scout','bombardier','bombardier'];
  let k=0;
  for(let r=1;r<=2;r++){
    for(let c=1;c<=10;c++){
      // skip if core occupies (row2 cols5-6)
      if((r===2) && (c===5||c===6)) continue;
      if(k < aPieces.length) setOcc(r,c,{player:PLAYER.A,type:aPieces[k++]});
    }
  }
  // Fill last two rows (9-10) for B with same pieces (skip core positions)
  const bPieces = ['foreguard','foreguard','foreguard','foreguard','foreguard','foreguard','shield','shield','scout','scout','bombardier','bombardier'];
  k=0;
  for(let r=10;r>=9;r--){
    for(let c=10;c>=1;c--){
      if((r===9) && (c===8||c===9)) continue;
      if(k < bPieces.length) setOcc(r,c,{player:PLAYER.B,type:bPieces[k++]});
    }
  }
}

/* 렌더링 */
function renderCell(cell){
  const el = cell.el;
  el.innerHTML = '';
  const lbl = document.createElement('div'); lbl.className='label'; lbl.textContent = `${String.fromCharCode(96 + cell.c)}${cell.r}`;
  el.appendChild(lbl);
  el.classList.remove('highlight-move','highlight-attack','core-border');
  if(cell.occupant){
    const t = document.createElement('div');
    t.className = 'token ' + (cell.occupant.player===PLAYER.A ? 'black' : 'white');
    if(cell.occupant.type==='core'){ t.style.border = '3px solid #000'; el.classList.add('core-border'); t.style.width='42px'; t.style.height='42px'; }
    el.appendChild(t);
    const info = document.createElement('div'); info.style.position='absolute'; info.style.bottom='2px'; info.style.left='4px'; info.style.fontSize='9px'; info.style.color='#222';
    info.textContent = TYPES[cell.occupant.type].name || cell.occupant.type;
    el.appendChild(info);
  }
}
function renderAll(){
  grid.forEach(g=>renderCell(g));
  updateSidebar();
}

/* 사이드바 */
function updateSidebar(){
  turnBadge.textContent = `턴: 플레이어 ${currentPlayer===PLAYER.A ? '1(검정)' : '2(흰)'}`;
  selInfo.textContent = selected ? `${String.fromCharCode(96+selected.c)}${selected.r}` : '없음';
  pieceInfo.innerHTML = '';
  controls.innerHTML = '';
  if(selected){
    const occ = idx(selected.r, selected.c).occupant;
    pieceInfo.innerHTML = `<strong>${TYPES[occ.type].name}</strong> — 플레이어 ${occ.player===0? '1':'2'}`;
    const btnCancel = document.createElement('button'); btnCancel.textContent='선택 취소';
    btnCancel.onclick = ()=>{ selected=null; clearHighlights(); renderAll(); };
    controls.appendChild(btnCancel);
    // If Bombardier selected, add detonate control display when appropriate
    if(occ.type==='bombardier'){
      const detBtn = document.createElement('button'); detBtn.textContent='폭파 모드 (타겟 선택)';
      detBtn.onclick = ()=>{ // mark detonate targets (orthogonal up to range)
        clearHighlights();
        const targets = bombTargets(selected.r, selected.c);
        targets.forEach(t=> t.el.classList.add('highlight-attack'));
      };
      controls.appendChild(detBtn);
    }
  }
}

/* 클릭 이벤트 */
function onCellClick(r,c){
  const cell = idx(r,c);
  // If no selection: try select own piece (not core)
  if(!selected){
    if(!cell.occupant){ log('토큰을 선택하세요.'); return; }
    if(cell.occupant.player !== currentPlayer){ log('자신의 기물만 선택 가능합니다.'); return; }
    if(cell.occupant.type==='core'){ log('코어는 선택 불가합니다.'); return; }
    selected = {r,c};
    clearHighlights();
    highlightMovesAndAttacks(selected.r, selected.c);
    renderAll();
    return;
  }
  // If clicked same selected cell -> deselect
  if(selected.r===r && selected.c===c){ selected=null; clearHighlights(); renderAll(); return; }

  // If clicked highlighted move cell -> perform move or attack depending on highlight class
  if(cell.el.classList.contains('highlight-move')){
    performMove(selected, {r,c});
    selected=null; clearHighlights(); renderAll(); return;
  }
  if(cell.el.classList.contains('highlight-attack')){
    performAttack(selected, {r,c});
    selected=null; clearHighlights(); renderAll(); return;
  }

  // If detonate highlight (bomb targets) - handle as special attack
  if(cell.el.classList.contains('highlight-attack')){
    performAttack(selected,{r,c});
    selected=null; clearHighlights(); renderAll(); return;
  }

  log('유효한 행동을 선택하세요.');
}

/* 하이라이트 계산 */
function clearHighlights(){ grid.forEach(g=>{ g.el.classList.remove('highlight-move','highlight-attack'); }); }
function highlightMovesAndAttacks(r,c){
  const cell = idx(r,c); if(!cell || !cell.occupant) return;
  const occ = cell.occupant; const def = TYPES[occ.type];
  // Normal moves (empty destination)
  if(def.moveDirs){
    // if bombardier has range>1 allow up to range steps (orthogonal)
    const maxRange = def.range || 1;
    for(const [dr,dc] of def.moveDirs){
      for(let step=1; step<=maxRange; step++){
        const nr=r+dr*step, nc=c+dc*step;
        if(!inBoard(nr,nc)) break;
        const target = idx(nr,nc);
        if(target.occupant==null){
          target.el.classList.add('highlight-move');
        } else {
          // can't move beyond occupied (except scout jumping capture)
          break;
        }
      }
    }
  }
  // Attack rules per type
  if(def.attack==='push'){
    // Foreguard: if orth adjacent has enemy and the next cell in same dir is empty => highlight attack (target cell)
    for(const [dr,dc] of def.moveDirs){
      const ar=r+dr, ac=c+dc; const br=r+2*dr, bc=c+2*dc;
      if(!inBoard(ar,ac)) continue;
      const adj = idx(ar,ac);
      if(adj.occupant && adj.occupant.player !== occ.player){
        if(inBoard(br,bc) && idx(br,bc).occupant==null){
          // highlight target as attack (we will move into adj cell and push enemy to br,bc)
          adj.el.classList.add('highlight-attack');
        }
      }
    }
  } else if(def.attack==='melee'){
    // Shield: can move into adjacent enemy cell to capture (but attacker will be pushed back if attacked)
    for(const [dr,dc] of def.moveDirs){
      const ar=r+dr, ac=c+dc;
      if(!inBoard(ar,ac)) continue;
      const adj = idx(ar,ac);
      if(adj.occupant && adj.occupant.player !== occ.player){
        adj.el.classList.add('highlight-attack');
      }
    }
  } else if(def.attack==='jump'){
    // Scout: diagonal jump: if adjacent diagonal has enemy and landing beyond is empty -> highlight landing cell (attack)
    for(const [dr,dc] of def.moveDirs){
      const midr=r+dr, midc=c+dc; const landr=r+2*dr, landc=c+2*dc;
      if(!inBoard(midr,midc) || !inBoard(landr,landc)) continue;
      const mid=idx(midr,midc), land=idx(landr,landc);
      if(mid.occupant && mid.occupant.player !== occ.player && land.occupant==null){
        land.el.classList.add('highlight-attack');
      }
    }
  } else if(def.attack==='bomb'){
    // Bombardier: can detonate on any cell within orthogonal range (1..range) - highlight those cells (even occupied)
    const maxRange = def.range || 2;
    for(const [dr,dc] of def.moveDirs){
      for(let step=1; step<=maxRange; step++){
        const nr=r+dr*step, nc=c+dc*step;
        if(!inBoard(nr,nc)) break;
        idx(nr,nc).el.classList.add('highlight-attack');
        if(idx(nr,nc).occupant) break; // bomb line of sight stops at first occupied (optional); keep it simple
      }
    }
  }
}

/* 행동 수행: move & attack implementations */
function performMove(from, to){
  const src = idx(from.r, from.c), dst = idx(to.r, to.c);
  if(!src || !dst) return;
  // move occupant
  dst.occupant = src.occupant;
  src.occupant = null;
  logAction(`${playerName(currentPlayer)}가 ${coordToStr(from)} → ${coordToStr(to)} 이동`);
  checkVictoryForMove(dst);
  currentPlayer = 1 - currentPlayer;
  renderAll();
}

function performAttack(from, to){
  const src = idx(from.r, from.c), dst = idx(to.r, to.c);
  if(!src || !dst) return;
  const occ = src.occupant;
  const def = TYPES[occ.type];

  if(def.attack==='push'){
    // dst is adjacent enemy cell that will be pushed to next cell
    const dr = dst.r - src.r, dc = dst.c - src.c;
    const br = dst.r + dr, bc = dst.c + dc;
    const behind = inBoard(br,bc) ? idx(br,bc) : null;
    if(!behind || behind.occupant) { log('밀기 실패: 뒤칸이 비어있지 않습니다.'); return; }
    // move attacker into dst, push target to behind
    const targetOcc = dst.occupant;
    behind.occupant = targetOcc;
    dst.occupant = occ;
    src.occupant = null;
    logAction(`${playerName(currentPlayer)}의 선봉이 ${coordToStr(to)} 공격: 적을 ${coordToStr({r:br,c:bc})}으로 밀어냄`);
    checkVictoryForMove(dst);
  } else if(def.attack==='melee'){
    // Shield: capture adjacent enemy (simple replace). If attacked by others, shield resists push logic elsewhere.
    const targetOcc = dst.occupant;
    dst.occupant = occ;
    src.occupant = null;
    logAction(`${playerName(currentPlayer)}의 방패가 ${coordToStr(to)}의 적을 제거하고 자리 차지`);
    checkVictoryForMove(dst);
  } else if(def.attack==='jump'){
    // Scout: landed on 'to' cell; remove the jumped piece at midpoint
    const midr = (from.r + to.r)/2, midc = (from.c + to.c)/2;
    if(!Number.isInteger(midr) || !Number.isInteger(midc)){ log('점프 실패'); return; }
    const mid = idx(midr, midc);
    if(!mid || !mid.occupant || mid.occupant.player === occ.player){ log('점프 실패: 중간에 적이 없습니다.'); return; }
    // remove mid occupant, move scout to landing cell
    mid.occupant = null;
    dst.occupant = occ;
    src.occupant = null;
    logAction(`${playerName(currentPlayer)}의 정찰병이 ${coordToStr({r:midr,c:midc})}의 적을 제압하고 ${coordToStr(to)}로 점프`);
    checkVictoryForMove(dst);
  } else if(def.attack==='bomb'){
    // Bombardier: detonate at target cell 'to': affect 3x3 around 'to', remove enemy non-core pieces
    const center = dst;
    const affected = [];
    for(let rr = center.r -1; rr <= center.r +1; rr++){
      for(let cc = center.c -1; cc <= center.c +1; cc++){
        if(!inBoard(rr,cc)) continue;
        const t = idx(rr,cc);
        if(t.occupant && t.occupant.player !== occ.player && t.occupant.type !== 'core'){
          affected.push({r:rr,c:cc});
        }
      }
    }
    // Move bomber into target cell if empty; otherwise bomber stays but still detonates.
    if(dst.occupant==null){
      dst.occupant = occ;
      src.occupant = null;
    } else {
      // bomber cannot move into occupied cell; stays
    }
    // remove affected enemy pieces
    affected.forEach(a=> idx(a.r,a.c).occupant = null);
    logAction(`${playerName(currentPlayer)}의 포격병이 ${coordToStr({r:dst.r,c:dst.c})}를 폭파, ${affected.length}개 제거`);
    checkVictoryForMove(dst);
  }

  // After any attack, change turn
  currentPlayer = 1 - currentPlayer;
  renderAll();
}

/* Utility: when a piece moved into opponent core cell => victory */
function checkVictoryForMove(dstCell){
  // If dstCell is in opponent core and occupant.player === currentPlayer -> win
  const occ = dstCell.occupant;
  if(!occ) return;
  const opponent = 1 - occ.player;
  // find opponent core cells
  const opponentCoreCells = grid.filter(g => g.occupant && g.occupant.type==='core' && g.occupant.player===opponent);
  // if any core cell is now owned by the moving player -> victory
  // Our design: core is specific; occupation means occupant.player matches player; but core cells initially have occupant.type='core' and owner the original player.
  // To capture core, we allow moving into a core cell replacing it (except core immobile). So logic: if any core cell occupant exists and occupant.player !== original owner -> victory.
  // Here we detect if any cell of opponent core has occupant and occupant.player === occ.player
  for(const c of opponentCoreCells){
    // if its occupant player has changed (i.e., player occupies opponent core spot)
    if(c.occupant && c.occupant.player === occ.player){
      // victory
      log(`<strong>🎉 플레이어 ${occ.player===0? '1(검정)' : '2(흰)'} 승리 — 코어 점령</strong>`);
      // disable further interaction by clearing selection and locking a flag
      selected = null;
      // prevent further clicks by removing handlers
      grid.forEach(g=> g.el.style.pointerEvents='none');
      return;
    }
  }
}

/* Bomb targets helper */
function bombTargets(r,c){
  const maxRange = TYPES['bombardier'].range || 2;
  const targets = [];
  for(const [dr,dc] of TYPES['bombardier'].moveDirs){
    for(let step=1; step<=maxRange; step++){
      const nr = r + dr*step, nc = c + dc*step;
      if(!inBoard(nr,nc)) break;
      targets.push(idx(nr,nc));
      if(idx(nr,nc).occupant) break;
    }
  }
  return targets;
}

/* Helpers for coords & names */
function coordToStr({r,c}){ return `${String.fromCharCode(96+c)}${r}`; }
function playerName(p){ return p===PLAYER.A ? '플레이어1(검정)' : '플레이어2(흰)'; }
function inBoard(r,c){ return r>=1 && r<=ROWS && c>=1 && c<=COLS; }

/* Logging action */
function logAction(s){ log(s); }

/* 초기 실행 */
initGrid();
log('게임 시작. 플레이어1(검정) 차례.');

/* 클릭 outside handlers to compute attack move highlights done by highlightMovesAndAttacks already */

/* keyboard shortcut: R reset */
window.addEventListener('keydown', e=>{
  if(e.key.toLowerCase()==='r'){ initGrid(); log('리셋 완료'); }
});

</script>
</body>
</html>
